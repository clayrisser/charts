{{- $serviceAccount := lookup "v1" "ServiceAccount" .Release.Namespace "aws-elevated" }}
apiVersion: integration.rock8s.com/v1alpha2
kind: Socket
metadata:
  name: aws-creds
  labels:
    app.kubernetes.io/name: {{ template "aws-creds.name" . }}
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
spec:
  epoch: {{ now | unixEpoch | quote }}
  interfaceVersions: '*'
  interface:
    name: aws-creds
    namespace: {{ .Release.Namespace }}
  config: {}
  resources:
    - when: [coupled, updated]
      do: recreate
      resource: |
        apiVersion: batch/v1
        kind: Job
        metadata:
          name: {{ template "aws-creds.name" . }}-coupled-or-updated-{% .plug.metadata.namespace %}
        spec:
          activeDeadlineSeconds: 360
          backoffLimit: 6
          ttlSecondsAfterFinished: 360
          template:
            metadata:
              annotations:
                sidecar.istio.io/inject: 'false'
            spec:
              automountServiceAccountToken: true
              {{- if (and (and $serviceAccount $serviceAccount.metadata) $serviceAccount.metadata.name) }}
              serviceAccountName: {{ $serviceAccount.metadata.name }}
              {{- else }}
              serviceAccountName: default
              {{- end }}
              restartPolicy: Never
              affinity:
                nodeAffinity:
                  requiredDuringSchedulingIgnoredDuringExecution:
                    nodeSelectorTerms:
                      - matchExpressions:
                          - key: kubernetes.io/arch
                            operator: In
                            values:
                              - amd64
              containers:
                - name: kubectl
                  image: registry.gitlab.com/bitspur/rock8s/images/kube-commands-aws:0.0.1
                  imagePullPolicy: Always
                  env:
                    - name: PLUG_NAMESPACE
                      value: {% .plug.metadata.namespace | quote %}
                    - name: RESOURCE_IDENTIFIER
                      value: {% .plugConfig.resourceIdentifier | quote %}
                    - name: RESOURCE_NAME
                      value: {% .plugConfig.resourceName %}
                    - name: AWS_SHARED_CREDENTIALS_FILE
                      value: /var/run/secrets/aws/credentials
                    - name: AWS_PROFILE
                      value: default
                  command:
                    - sh
                    - -c
                    - |
                      echo PLUG_NAMESPACE $PLUG_NAMESPACE
                      echo RESOURCE_IDENTIFIER $RESOURCE_IDENTIFIER
                      echo RESOURCE_NAME $RESOURCE_NAME
                      USER_RESOURCE_NAME=$RESOURCE_NAME.$(echo $RESOURCE_IDENTIFIER | sed 's|\.services\.k8s\.aws$||g').$PLUG_NAMESPACE
                      USERNAME=$USER_RESOURCE_NAME.{{ template "aws-creds.cluster-name" . }}
                      SERVICE=$(echo $RESOURCE_IDENTIFIER | sed 's|\.services\.k8s\.aws$||g' | sed 's|.\+\.||g')
                      echo USERNAME $USERNAME
                      echo SERVICE $SERVICE
                      ARN=""
                      while [ "$ARN" = "" ]; do
                        if [ "$(kubectl get $RESOURCE_IDENTIFIER $RESOURCE_NAME -n $PLUG_NAMESPACE -o jsonpath='{.status.conditions[0].type}')" = "ACK.ResourceSynced" ]; then
                          ARN="arn:aws:$SERVICE:::$(kubectl get $RESOURCE_IDENTIFIER $RESOURCE_NAME -n $PLUG_NAMESPACE -o jsonpath='{.spec.name}')"
                        fi
                        if [ "$ARN" = "" ]; then
                          echo "arn not available yet. Retrying in 5 seconds..."
                          sleep 5
                        fi
                      done
                      echo ARN $ARN
                      cat <<EOF | kubectl apply -f -
                      apiVersion: iam.services.k8s.aws/v1alpha1
                      kind: User
                      metadata:
                        name: $USER_RESOURCE_NAME
                        namespace: {{ .Release.Namespace }}
                      spec:
                        name: $USERNAME
                        inlinePolicies:
                          policy: |
                            {
                              "Version": "2012-10-17",
                              "Statement": [
                                {
                                  "Effect": "Allow",
                                  "Action": [
                                    "$SERVICE:*"
                                  ],
                                  "Resource": [
                                    "$ARN",
                                    "$ARN/*"
                                  ]
                                }
                              ]
                            }
                        tags:
                          - key: resource-identifier
                            value: $RESOURCE_IDENTIFIER
                          - key: resource-name
                            value: $RESOURCE_NAME
                          - key: namespace
                            value: $PLUG_NAMESPACE
                          - key: cluster-name
                            value: {{ template "aws-creds.cluster-name" . }}
                      EOF
                      if kubectl get secret $RESOURCE_NAME.$RESOURCE_IDENTIFIER --namespace=$PLUG_NAMESPACE >/dev/null 2>&1; then
                        echo "secret/$RESOURCE_NAME.$RESOURCE_IDENTIFIER already exists in namespace $PLUG_NAMESPACE"
                      else
                        OUT=$(aws iam create-access-key --user-name $USERNAME --query 'AccessKey.[AccessKeyId,SecretAccessKey]' --output text)
                        ACCESS_KEY=$(echo $OUT | cut -d' ' -f1)
                        SECRET_KEY=$(echo $OUT | cut -d' ' -f2)
                        kubectl create secret generic $RESOURCE_NAME.$RESOURCE_IDENTIFIER \
                          --from-literal=accessKey=$ACCESS_KEY \
                          --from-literal=secretKey=$SECRET_KEY \
                          --namespace=$PLUG_NAMESPACE
                      fi
                      kubectl get pods -n {{ .Release.Namespace }} \
                        -l job-name={{ template "aws-creds.name" . }}-coupled-or-updated-{% .plug.metadata.namespace %} \
                        --field-selector status.phase=Failed \
                        -o yaml | kubectl delete -f -
                  volumeMounts:
                    - name: aws-creds
                      mountPath: /var/run/secrets/aws
                      readOnly: true
              volumes:
                - name: aws-creds
                  secret:
                    secretName: aws-creds
    - when: [decoupled]
      do: recreate
      resource: |
        apiVersion: batch/v1
        kind: Job
        metadata:
          name: {{ template "aws-creds.name" . }}-decoupled-{% .plug.metadata.namespace %}
        spec:
          activeDeadlineSeconds: 360
          backoffLimit: 6
          ttlSecondsAfterFinished: 360
          template:
            metadata:
              annotations:
                sidecar.istio.io/inject: 'false'
            spec:
              automountServiceAccountToken: true
              restartPolicy: Never
              affinity:
                nodeAffinity:
                  requiredDuringSchedulingIgnoredDuringExecution:
                    nodeSelectorTerms:
                      - matchExpressions:
                          - key: kubernetes.io/arch
                            operator: In
                            values:
                              - amd64
              containers:
                - name: kubectl
                  image: registry.gitlab.com/bitspur/rock8s/images/kube-commands-aws:0.0.1
                  imagePullPolicy: Always
                  env:
                    - name: PLUG_NAMESPACE
                      value: {% .plug.metadata.namespace | quote %}
                    - name: RESOURCE_IDENTIFIER
                      value: {% .plugConfig.resourceIdentifier | quote %}
                    - name: RESOURCE_NAME
                      value: {% .plugConfig.resourceName %}
                  command:
                    - sh
                    - -c
                    - |
                      echo PLUG_NAMESPACE $PLUG_NAMESPACE
                      echo RESOURCE_IDENTIFIER $RESOURCE_IDENTIFIER
                      echo RESOURCE_NAME $RESOURCE_NAME
                      USER_RESOURCE_NAME=$RESOURCE_NAME.$(echo $RESOURCE_IDENTIFIER | sed 's|\.services\.k8s\.aws$||g').$PLUG_NAMESPACE
                      USERNAME=$USER_RESOURCE_NAME.{{ template "aws-creds.cluster-name" . }}
                      SERVICE=$(echo $RESOURCE_IDENTIFIER | sed 's|\.services\.k8s\.aws\/.\+||g' | sed 's|.\+\.||g')
                      echo USERNAME $USERNAME
                      echo SERVICE $SERVICE
                      cat <<EOF | kubectl delete -f -
                      apiVersion: iam.services.k8s.aws/v1alpha1
                      kind: User
                      metadata:
                        name: $USER_RESOURCE_NAME
                        namespace: {{ .Release.Namespace }}
                      EOF
                      kubectl delete secret generic $RESOURCE_IDENTIFIER-aws-creds \
                        --namespace=$PLUG_NAMESPACE
                      kubectl get pods -n {{ .Release.Namespace }} \
                        -l job-name={{ template "aws-creds.name" . }}-decoupled-{% .plug.metadata.namespace %} \
                        --field-selector status.phase=Failed \
                        -o yaml | kubectl delete -f -
